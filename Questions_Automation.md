# Что такое IaaC и зачем он нужен?

IaaC означает "Infrastructure as Code" (Инфраструктура как Код) и представляет собой подход к управлению и автоматизации конфигурации инфраструктуры через код. Вместо традиционного ручного настройки или управления инфраструктурой через интерфейс пользователя, как это делается вручную, IaaC позволяет определять и управлять инфраструктурой так же, как управляется код программы.  
  
Использование IaaC имеет множество преимуществ, включая:  
  
1. **Скорость и консистентность**: Возможность автоматизировать развертывание и настройку инфраструктуры, что сокращает время и обеспечивает ее консистентность в разных средах.  
  
2. **Гибкость и масштабируемость**: Возможность легко масштабировать и изменять инфраструктуру за счет простых изменений в коде.  
  
3. **Отслеживаемость и воспроизводимость**: Вся инфраструктура определена и управляется через код, что упрощает отслеживание изменений и воспроизведение конфигурации в различных условиях.  
  
4. **Коллективная работа**: Код инфраструктуры хранится в репозитории версий, что позволяет командам совместно работать и отслеживать изменения.  
  
Таким образом, IaaC помогает упростить управление инфраструктурой, повысить ее надежность, автоматизировать процессы и ускорить развертывание приложений. Он позволяет инженерам управлять инфраструктурой как кодом, что является современным и эффективным подходом к управлению облачными ресурсами.

---

# Что такое Terraform?

Терраформ - это инструмент для управления инфраструктурой как кодом, разработанный компанией HashiCorp. С помощью Terraform вы можете описать нужную инфраструктуру в виде декларативного кода на специальном языке конфигурации (HCL) и затем разворачивать эту инфраструктуру автоматически.  
  
Основные преимущества использования Terraform:  
  
1. **Мульти-провайдерность**: Terraform поддерживает множество провайдеров облачных инфраструктур, таких как AWS, Azure, Google Cloud, Kubernetes и другие.  
  
2. **Декларативный подход**: Вы определяете желаемое состояние инфраструктуры, а Terraform самостоятельно решает, как добиться этого состояния, обеспечивая согласованность инфраструктуры.  
  
3. **Чистота и легкость изменения**: Изменения инфраструктуры могут быть внесены легко путем изменения кода, что упрощает отслеживание изменений и повторяемость в различных средах.  
  
4. **Модульность и гибкость**: Вы можете создавать многоразовые модули Terraform для описания частей инфраструктуры и повторно использовать их в различных проектах.  
  
5. **Интеграция с другими инструментами**: Terraform легко интегрируется с другими инструментами автоматизации, контейнеризации и управления конфигурациями с помощью множества плагинов.  
  
Использование Terraform позволяет ускорить и автоматизировать процесс развертывания и управления инфраструктурой, улучшить продуктивность команды и сделать инфраструктуру более гибкой и масштабируемой.

---

## Что содержит код Terraform?

Ресурсы облачного провайдера, а также провижининг для создаваемых ресурсов.

---

## Как хранить состояние инфраструктуры в Terraform?

Например, можно хранить tfstate в git-репозитории команды. Другой вариант - хранить в специализированном Terraform Backend.

---

## Terraform Backend. Какой лучше?

Зависит от требованиям к хранению состояния.

- AWS S3 — Standard (с блокировкой через DynamoDB). Сохраняет состояние в виде заданного ключа в заданном сегменте на Amazon S3. Этот бэкэнд также поддерживает блокировку состояния и проверку согласованности через DynamoDB.
    
- terraform enterprise — Standard (без блокировки).
    
- etcd — Standard (без блокировки). Сохраняет состояние в etcd 2.x по заданному пути.
    
- etcdv3 — Standard (с блокировкой). Сохраняет состояние в хранилище etcd в виде K/V с заданным префиксом.
    
- gcs — Standard (с блокировкой). Сохраняет состояние как объект в настраиваемом префиксе в заданном сегменте в Google Cloud Storage (GCS). Этот бэкэнд также поддерживает блокировку состояния.
    
- Gitlab Terraform state (с блокировкой). Хранит состояние в Gitlab Terraform state хранилище, используя HTTP протокол и права Gitlab для доступа.
    

Существуют также и другие Backend для Terraform.

---

## Как добавить имеющиеся ресурсы в tfstate?

```
terraform import [options] ADDRESS ID
```

1. Например, создаем директорию и инициализируем будущую инфраструктуру:

```
mkdir terraform-test
cd terraform-test
terraform init
vi main.tf
```

2. Добавляем в файл main.tf следующий код:

```
provider "aws" {
  region = "us-west-1"
  profile = "tyx-local"
}
resource "aws_s3_bucket" "sample_bucket" {
  bucket = "tyx-local-bucket"
  acl = "public"
}
```

3. Выполняем импорт ресурса:

```
terraform import aws_s3_bucket.sample_bucket tyx-local-bucket
```

---
## Зачем нужен `terraform taint`?

Команда `terraform taint` пометит ресурс инфраструктуры, который будет удален и заново создан при следующем применении команды `terraform apply`.

---
## Как проводить тестирование terraform?

`terraforn plan` выполнит проверку действующего кода. Работу с облачными ресурсами выполнит

---
## Что такое модуль в terraform? Для чего он нужен?

Модуль в Terraform - пакет конфигурации Terraform, который можно использовать при повторной конфигурации компонентов инфраструктуры, а также базовой организации кода Terraform в директориях. При подключения модуля, ему даётся имя.

---

## Как хранить переменные в terraform?

_main.tf_ - основной конфигурационный файл, описывающий какие инстансы необходимо создать. _variables.tf_ - конфигурация с описанием переменных и значениями по-умолчанию. Если значения по-умолчанию не задано, то они являются обязательными. _terraform.tfvars_ - конфигурация со значениями переменных. Часто является секретным файлом, поэтому нужно с осторожностью пушить в публичные репозитарии. _outputs.tf_ - описание выходных переменных. Необязательный файл, но очень удобно выделять нужные параметры из созданного инстанса, например IP созданного в облаке инстанса.

---

## Как конвертировать Kubernetes yaml-манифест в HCL средствами Linux и terraform?

```
echo 'yamldecode(file("filename.yaml"))' | terraform console
```

---
## Что такое Workspaces в Terraform?

[Workspaces](https://developer.hashicorp.com/terraform/language/state/workspaces#using-workspaces) в Terraform - это возможность управления state файлами. Workspace содержит все что необходимо для управления набором инфраструктуры, а отдельные рабочие области функционируют как полностью отдельные рабочие каталоги. С помощью Workspaces возможно управлять несколькими средами инфраструктуры.

---
## Для чего нужен terragrunt?

Terragrunt — это обертка для Terraform, позволяющая решать проблемы, связанные с масштабированием и переиспользованием кода для настройки инфраструктуры. Он позволяет повторно использовать конфигурационные параметры и поддерживает многоуровневые конфигурации и зависимости.

---
## Чем отличается `count` от `for_each`?

`count` — это итерация по списку, который содержит целочисленные элементы, `for_each` — это итерация по корневым ключам словаря, которые могут содержать данные любого типа.

```
resource "aws_instance" "web" {
  count = 3
 
  instance_type = "t2.micro"
  ami           = data.aws_ami.debian_buster.id
  tags = {
    Name = "WebServer-${count.index + 1}"
  }
}
```

Описание ресурса выше создаст 3 одинаковых EC2 инстанса, изменив имя с указанием номера текущего состояния счётчика. `count` начинает отсчет с 0, поэтому чтобы 1 EC2 инстанс был с индексом 1 в имени ему прибавили `1`.

```
resource "aws_instance" "server" {
  for_each = {
    web = { type = "t2.micro", public_ip = true },
    db  = { type = "m5.large", public_ip = false }
  }
 
  instance_type = each.value["type"]
  ami           = data.aws_ami.debian_buster.id
  associate_public_ip_address = each.value["public_ip"]
  tags = {
    Name = "each.key"
  }
}
```

Ресурс выше создаст 2 EC2 инстанса с итерацией по ключам `each.key` и использовав значения вложенных словарей в конфигурации EC2.

---
# Какие инструменты автоматизации вы знаете?

1. **Ansible**: Это инструмент управления конфигурациями и автоматизации процессов на основе модулей. Он позволяет управлять конфигурациями серверов, сетевых устройств и других систем.  
  
2. **Puppet**: Puppet также используется для управления конфигурацией, осуществления автоматического развертывания и управления инфраструктурой целиком.  
  
3. **Chef**: Chef предоставляет собой платформу для автоматизации управления конфигурациями и развертывания приложений на серверах.  
  
4. **Jenkins**: Это инструмент для непрерывной интеграции и непрерывной доставки (CI/CD), который помогает автоматизировать процессы сборки, тестирования и развертывания приложений.  
  
5. **GitLab CI/CD**: Инструмент для автоматизации тестирования, сборки и развертывания приложений на основе GitLab.  
  
6. **CircleCI**: Это облачный сервис для автоматизации CI/CD-процессов. Он интегрируется с GitHub и другими системами управления кодом.  
  
7. **Travis CI**: Еще один популярный сервис для непрерывной интеграции и доставки кода.  
  
Эти инструменты помогают ускорить и упростить процессы разработки, тестирования и доставки ПО, делая их более надежными, эффективными и масштабируемыми.

---
# Чем отличаются Ansible модули _raw_, _command_ и _shell_?

Модуль _raw_ отличается от _command_ и _shell_ тем, что не выполняет дополнительную обработку выполнения команды. Эти дополнительные обработки присутствуют в почти любом модуле Ansible. Модуль _raw_ передает команду, как есть, в "сыром" (raw) виде без проверок. Модули _command_ и _shell_ отличаются тем, что в модуле _command_ команда выполняется без прохождения через командную оболочку `/bin/sh`. Поэтому переменные определенные в оболочке и перенаправления - конвееры работать не будут. Модуль _shell_ выполняет команды через оболочку по умолчанию `/bin/sh`. Поэтому там будут доступны переменные оболочки и перенаправления.

---
# На всех серверах должен быть набор пользователей, с доступом по ssh-ключу, стандартный модуль user не позволяет вносить ssh ключ в authorized_keys. Предложите решение.

1. Использовать модуль `authorized_key` для добавления ключей.
2. Использовать модуль `shell`, чтобы вручную с использованием команды `cat {{ PUBLIC_SSH_KEY }} >> /home/{{ USER }}/.ssh/authorized_keys` добавить ключ. В данном случае шаблоны Jinja2 PUBLIC_SSH_KEY и USER должны быть заданы.

---
# Есть группы пользователей, которые должны заводиться не на всех серверах. Как ограничить заведение пользователей?

Сгруппировать сервера, на которых должны заводиться группы пользователей, в INVENTORY или написать в PLAYBOOK условие, которому передаётся список серверов, на которых необходимо выполнить задачу.

---
# На новом сервере не установлен Python, который требуется для работы Ansible. Как выполнить установку Python на сервере используя Ansible?

Использовать модуль `raw`, которому необходимо передать команду для установки python на сервере. Модуль `raw` принимает команду без дополнительной обработки Python и выполняет её на сервере.

---
# Что такое роль в Ansible? Что содержит в себе Ansible роль?

Ansible роль представляет собой структурированный плейбук, содержащий, как минимум, набор задач (tasks) и дополнительно - обработчики событий (handlers), переменных (default и vars), файлов (files), шаблонов (templates), описание и зависимости (metadata) и тесты (tests).

---
# В Ansible роли есть директории _vars_ и _default_. Что они содержат и чем отличаются?

Ansible применяет порядок приоритета переменных. Ниже представлен список в порядке повышения приоритета.

1. command line values (for example, -u my_user, these are not variables)
2. role defaults (defined in role/defaults/main.yml)
3. inventory file or script group vars
4. inventory group_vars/all
5. playbook group_vars/all
6. inventory group_vars/*
7. playbook group_vars/*
8. inventory file or script host vars
9. inventory host_vars/*
10. playbook host_vars/*
11. host facts / cached set_facts
12. play vars
13. play vars_prompt
14. play vars_files
15. role vars (определяемые в role/vars/main.yml)
16. block vars (только для задач в `block`)
17. task vars (только для задач)
18. include_vars
19. set_facts / registered vars
20. role (и include_role) params
21. include params
22. extra vars (например, -e "user=my_user")(всегда приоритетнее)

Соответственно переменные в _vars_ будут приорететнее, чем в _defaults_.

---
# В Ansible роли есть директории _file_ и _templates_. Что они содержат и чем отличаются?
 
_files_ - содержит файлы, которые будут скопированы на настраиваемые хосты; так же — может содержать скрипты, которые позже будут запускаться на хостах.

_templates_ - содержит шаблоны файлов с переменными.

---
# По-умолчанию, в Ansible все задачи из списка выполняются параллельно на всех хостах, которые указаны в `hosts`. Как сделать так, чтобы задачи выполнялись последовательно по хостам?

Необходимо установить параметр `serial: 1`, чтобы определить количество хостов, на которых будут выполняться паралелльно задачи. Значение 1 будет значить, что все задачи будут проходить параллельно по 1 хосту за раз.

Ссылка на документацию: [https://docs.ansible.com/ansible/latest/user_guide/playbooks_strategies.html#setting-the-batch-size-with-serial](https://docs.ansible.com/ansible/latest/user_guide/playbooks_strategies.html#setting-the-batch-size-with-serial)

